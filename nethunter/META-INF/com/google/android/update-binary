#!/sbin/sh
## Kali NetHunter installer

## Detect bootmode
## "BOOTMODE=true"  = Device has booted into system (NetHunter installed as Magisk module)
## "BOOTMODE=false" = Device has booted into recovery (NetHunter installed through TWRP)
##
## Apps
##   NetHunter.apk
##     https://gitlab.com/kalilinux/nethunter/apps/kali-nethunter-app
##     https://store.nethunter.com/packages/com.offsec.nethunter/
##   NetHunterTerminal.apk
##     https://gitlab.com/kalilinux/nethunter/apps/kali-nethunter-term
##     https://store.nethunter.com/packages/com.offsec.nhterm/
##   NetHunterKeX.apk
##     https://gitlab.com/kalilinux/nethunter/apps/kali-nethunter-kex
##     https://store.nethunter.com/packages/com.offsec.nethunter.kex/
##   NetHunterStore.apk
##     https://gitlab.com/kalilinux/nethunter/apps/kali-nethunter-store-client
##     https://store.nethunter.com/packages/com.offsec.nethunter.store/
##   NetHunterStorePrivilegedExtension.apk
##     https://gitlab.com/kalilinux/nethunter/apps/kali-nethunter-store-privileged-extension
##     https://store.nethunter.com/packages/com.offsec.nethunter.store.privileged/

BOOTMODE=false;
ps | grep zygote | grep -v grep >/dev/null && BOOTMODE=true;
$BOOTMODE || ps -A 2>/dev/null | grep zygote | grep -v grep >/dev/null && BOOTMODE=true;

###################################
##                               ##
##  Install in Magisk            ##
##                               ##
###################################

if $BOOTMODE; then
  require_new_magisk() {
    echo "*******************************"
    echo " Please install Magisk v20.4+! "
    echo "*******************************"
    exit 1
  }

  #################
  # Initialization
  #################
  umask 022

  #########################
  # Load util_functions.sh
  #########################
  OUTFD=$2
  ZIPFILE=$3

  mount /data 2>/dev/null

  [ -f /data/adb/magisk/util_functions.sh ] || require_new_magisk
  . /data/adb/magisk/util_functions.sh
  [ $MAGISK_VER_CODE -lt 20400 ] && require_new_magisk

  #########################
  # Install module
  #########################
  rm -rf $TMPDIR
  mkdir -p $TMPDIR

  setup_flashable
  mount_partitions
  api_level_arch_detect

  # Setup BusyBox and binaries
  boot_actions

  # Extract prop file
  unzip -jo "$ZIPFILE" tools/module.prop -d $TMPDIR >&2
  [ ! -f $TMPDIR/module.prop ] && abort "! Unable to extract zip file!"

  MODDIRNAME=modules_update
  MODID=$(grep_prop id $TMPDIR/module.prop)
  MODNAME=$(grep_prop name $TMPDIR/module.prop)
  MODAUTH=$(grep_prop author $TMPDIR/module.prop)
  MODPATH=$NVBASE/$MODDIRNAME/$MODID

  # Create mod paths
  rm -rf $MODPATH
  mkdir -p $MODPATH

  ## Install NetHunter
  unzip -jo "$ZIPFILE" META-INF/com/google/android/update-magisk -d $MODPATH >&2
  set_perm_recursive $MODPATH 0 0 0755 0644
  [ -f $MODPATH/update-magisk ] && . $MODPATH/update-magisk

  # Clean up
  rm -rf $MODPATH/update-magisk \
  $MODPATH/system/placeholder $MODPATH/customize.sh \
  $MODPATH/README.md $MODPATH/.git*
  rm -rf $TMPDIR
  cd /

  exit 0
fi

###################################
##                               ##
##  Install in TWRP              ##
##                               ##
###################################

progress() {
  echo "set_progress $1" > "$console"
}

print() {
  echo "${1:- }" \
    | while read -r line; do
       echo -e "ui_print $line" > "$console"
       echo -e "ui_print \n" > "$console"
    done
}

abort() {
  [ "$1" ] && {
    print "! Error: $1"
    print "* Aborting"
  }
  restore_env
  print "* Failed to install Kali NetHunter!"
  exit 1
}

cleanup() {
  [ "$ZIPFILE" ] && {
   rm /tmp/console
  }
  cd $(dirname $tmp)
  rm -rf $tmp
}

install() {
  setperm "$2" "$3" "$tmp$1"
  if [ "$4" ]; then
    cp -r "$tmp$1" "$(dirname "$4")/"
    return
  fi
  cp -r "$tmp$1" "$(dirname "$1")/"
}

# installapp_user "App Name" "appfile.apk" "play.store.package.name"
#   if the app package is found in the play store app database, then don't install it
installapp_user() {
  installto=/data/app/
  if [ "$2" ]; then
    for appdir in "/data/app/$2-"*; do
      [ -d "$appdir" ] || continue
      print "Found app directory: $appdir"
      if [ ! -f /data/data/com.android.vending/databases/localappstate.db ]; then
        print "Could not find Play Store app database!"
      # This should also catch paid/alternative versions if they are suffixed
      elif strings /data/data/com.android.vending/databases/localappstate.db | grep -q "^$2"; then
        rm -f "/data/app/$1"
        print "* Found Play Store installed $1"
        return 0
      fi
      rm -f "/data/app/$1"
      installto=$appdir/base.apk
      break
    done
  fi

  #print "* Installing $1 to $installto"
  print "*** Installing $1"
  cp -f "$tmp/data/app/$1" "$installto" && return 0
  print "* Failed to install $1!" && return 1
}

installapp_system() {
  check_freespace $tmp/data/app/
  print "*** Installing $1"
  mkdir -p ${SYSTEM}/${3:-app}/$2/
  cp -f $tmp/data/app/$1 ${SYSTEM}/${3:-app}/$2/ && return 0
  print "* Failed to install $1!" && return 1
}

extract() {
  rm -rf "$2"
  mkdir -p "$2"
  unzip -o "$1" -d "$2" -x "$3" ||
    abort "Unable to extract! The zip may be corrupt or your device may not have enough RAM to proceed. Consider using a smaller installer if it is available"
}

setperm() {
  find "$3" -type d -exec chmod "$1" {} \;
  find "$3" -type f -exec chmod "$2" {} \;
}

symlink() {
  rm "$2"
  ln -s "$1" "$2"
}

setup_mountpoint() {
  [ -L $1 ] && $BB mv -f $1 ${1}_link;
  if [ ! -d $1 ]; then
    $BB rm -f $1;
    $BB mkdir -p $1;
  fi;
}

is_mounted() {
  $BB mount | $BB grep -q " $1 ";
}

mount_apex() {
  [ -d /system_root/system/apex ] || return 1;
  local apex dest loop minorx num var;
  setup_mountpoint /apex;
  minorx=1;
  [ -e /dev/block/loop1 ] && minorx=$($BB ls -l /dev/block/loop1 | $BB awk '{ print $6 }');
  num=0;
  for apex in /system_root/system/apex/*; do
    dest=/apex/$($BB basename $apex .apex);
    case $dest in
      *.current|*.release) dest=$(echo $dest | $BB rev | $BB cut -d. -f2- | $BB rev);;
    esac;
    $BB mkdir -p $dest;
    case $apex in
      *.apex)
        $BB unzip -qo $apex apex_payload.img -d /apex;
        $BB mv -f /apex/apex_payload.img $dest.img;
        $BB mount -t ext4 -o ro,noatime $dest.img $dest 2>/dev/null;
        if [ $? != 0 ]; then
          while [ $num -lt 64 ]; do
            loop=/dev/block/loop$num;
            ($BB mknod $loop b 7 $((num * minorx));
            $BB losetup $loop $dest.img) 2>/dev/null;
            num=$((num + 1));
            $BB losetup $loop | $BB grep -q $dest.img && break;
          done;
          $BB mount -t ext4 -o ro,loop,noatime $loop $dest;
          if [ $? != 0 ]; then
            $BB losetup -d $loop 2>/dev/null;
          fi;
        fi;
      ;;
      *) $BB mount -o bind $apex $dest;;
    esac;
  done;

  for var in $($BB grep -o 'export .* /.*' /system_root/init.environ.rc | $BB awk '{ print $2 }'); do
    eval OLD_${var}=\$$var;
  done;

  $($BB grep -o 'export .* /.*' /system_root/init.environ.rc | $BB sed 's; /;=/;'); unset export;
}

umount_apex() {
  [ -d /apex/com.android.runtime ] || return 1;
  local dest loop var;
  for var in $($BB grep -o 'export .* /.*' /system_root/init.environ.rc | $BB awk '{ print $2 }'); do
    if [ "$(eval echo \$OLD_$var)" ]; then
      eval $var=\$OLD_${var};
    else
      eval unset $var;
    fi;
    unset OLD_${var};
  done;

  for dest in $($BB find /apex -type d -mindepth 1 -maxdepth 1); do
    if [ -f $dest.img ]; then
      loop=$($BB mount | $BB grep $dest | $BB cut -d\  -f1);
    fi;
    ($BB umount -l $dest;
    $BB losetup -d $loop) 2>/dev/null;
  done;

  $BB rm -rf /apex 2>/dev/null;
}

find_slot() {
  local slot=$(getprop ro.boot.slot_suffix 2>/dev/null);
  [ "$slot" ] || slot=$($BB grep -o 'androidboot.slot_suffix=.*$' /proc/cmdline | $BB cut -d\  -f1 | $BB cut -d= -f2);
  if [ ! "$slot" ]; then
    slot=$(getprop ro.boot.slot 2>/dev/null);
    [ "$slot" ] || slot=$($BB grep -o 'androidboot.slot=.*$' /proc/cmdline | $BB cut -d\  -f1 | $BB cut -d= -f2);
    [ "$slot" ] && slot=_$slot;
  fi;

  [ "$slot" ] && echo "$slot";
}

mount_all() {
  if ! is_mounted /cache; then
    $BB mount /cache 2>/dev/null
  fi;

  if ! is_mounted /data; then
    $BB mount /data
  fi;

  ($BB mount -o ro -t auto /vendor;
  $BB mount -o ro -t auto /product;
  $BB mount -o ro -t auto /persist) 2>/dev/null;
  setup_mountpoint $ANDROID_ROOT;
  if ! is_mounted $ANDROID_ROOT; then
    $BB mount -o ro -t auto $ANDROID_ROOT 2>/dev/null;
  fi;

  case $ANDROID_ROOT in
    /system_root) setup_mountpoint /system;;
    /system)
      if ! is_mounted /system && ! is_mounted /system_root; then
        setup_mountpoint /system_root;
        $BB mount -o ro -t auto /system_root;
      elif [ -f /system/system/build.prop ]; then
        setup_mountpoint /system_root;
        $BB mount --move /system /system_root;
      fi;
      if [ $? != 0 ]; then
        ($BB umount /system;
        $BB umount -l /system) 2>/dev/null;
        if [ -d /dev/block/mapper ]; then
          [ -e /dev/block/mapper/system ] || local slot=$(find_slot);
          $BB mount -o ro -t auto /dev/block/mapper/vendor$slot /vendor;
          $BB mount -o ro -t auto /dev/block/mapper/product$slot /product 2>/dev/null;
          $BB mount -o ro -t auto /dev/block/mapper/system$slot /system_root;
        else
          [ -e /dev/block/bootdevice/by-name/system ] || local slot=$(find_slot);
          ($BB mount -o ro -t auto /dev/block/bootdevice/by-name/vendor$slot /vendor;
          $BB mount -o ro -t auto /dev/block/bootdevice/by-name/product$slot /product;
          $BB mount -o ro -t auto /dev/block/bootdevice/by-name/persist$slot /persist) 2>/dev/null;
          $BB mount -o ro -t auto /dev/block/bootdevice/by-name/system$slot /system_root;
        fi;
      fi;
    ;;
  esac;

  if is_mounted /system_root; then
    mount_apex;
    if [ -f /system_root/build.prop ]; then
      $BB mount -o bind /system_root /system;
    else
      $BB mount -o bind /system_root/system /system;
    fi;
  fi;
}

umount_all() {
  local mount;
  (if is_mounted /system; then
    $BB umount /system;
    $BB umount -l /system;
  fi) 2>/dev/null;

  umount_apex;

  (if [ -e /system_root ]; then
    $BB umount /system_root;
    $BB umount -l /system_root;
  fi;

  umount /vendor; # BusyBox umount /vendor breaks recovery on some hacky devices
  umount -l /vendor;

  for mount in /mnt/system /mnt/vendor /product /mnt/product /persist; do
    $BB umount $mount;
    $BB umount -l $mount;
  done;

  if is_mounted /data; then
    $BB umount /data;
    $BB umount -l /data;
  fi;

  if is_mounted /cache; then
    $BB umount /cache;
    $BB umount -l /cache;
  fi) 2>/dev/null;
}

setup_env() {
  $BB mount -o bind /dev/urandom /dev/random;
  if [ -L /etc ]; then
    setup_mountpoint /etc;
    $BB cp -af /etc_link/* /etc;
    $BB sed -i 's; / ; /system_root ;' /etc/fstab;
  fi;

  umount_all;
  mount_all;
  if [ -d /dev/block/mapper ]; then
    for slot in "" _a _b; do
      $BB blockdev --setrw /dev/block/mapper/system$slot 2>/dev/null
    done
  fi
  $BB mount -o rw,remount -t auto /system 2>/dev/null || $BB mount -o rw,remount -t auto / 2>/dev/null
  OLD_LD_PATH=$LD_LIBRARY_PATH;
  OLD_LD_PRE=$LD_PRELOAD;
  OLD_LD_CFG=$LD_CONFIG_FILE;
  unset LD_LIBRARY_PATH LD_PRELOAD LD_CONFIG_FILE;
}

restore_env() {
  local dir;
  [ "$OLD_LD_PATH" ] && export LD_LIBRARY_PATH=$OLD_LD_PATH;
  [ "$OLD_LD_PRE" ] && export LD_PRELOAD=$OLD_LD_PRE;
  [ "$OLD_LD_CFG" ] && export LD_CONFIG_FILE=$OLD_LD_CFG;
  unset OLD_LD_PATH OLD_LD_PRE OLD_LD_CFG;
  umount_all;
  [ -L /etc_link ] && $BB rm -rf /etc/*;
  (for dir in /apex /system /system_root /etc; do
    if [ -L "${dir}_link" ]; then
      rmdir $dir;
      $BB mv -f ${dir}_link $dir;
    fi;
  done;
  $BB umount -l /dev/random) 2>/dev/null;

  print "* Cleaning up"
  cleanup
}

get_bb() {
  cd $tmp/tools
  BB_latest=$( (ls -v busybox_nh-* 2>/dev/null || ls busybox_nh-*) | tail -n 1)
  BB=$tmp/tools/$BB_latest # Use NetHunter BusyBox from tools
  chmod 0755 $BB # Make BusyBox executable
  echo $BB
  cd - >/dev/null
}

install_recovery_bb() {
  # To identify the latest BusyBox version, we need the command "ls -v" which is not supported by all TWRP versions
  # We will pick the best available BusyBox version and use that to run "ls -v" to pick the latest version for the recovery partition
  cd $tmp/tools

  # Try to pick the latest version of BusyBox, if "ls -v" is not supported by the recovery then make an educated guess for a later version
  recovery_bb=$( (ls -v busybox_nh-* 2>/dev/null || ls busybox_nh-*) | tail -n 1 )
  cp $recovery_bb busybox_tmp
  setperm 0755 0755 busybox_tmp

  # Now that we picked a reasonably current BusyBox, use that to copy the absolute latest to the recovery partition using "ls -v"
  nethunter_bb=$(./busybox_tmp ls -v busybox_nh-* | tail -n 1)
  print "*** Installing $nethunter_bb applets to /sbin"
  cp $nethunter_bb /sbin/busybox_nh
  /sbin/busybox_nh --install /sbin
  cd - >/dev/null
}

## Apps can be copy, but also unzip/extracted
check_freespace() {
  ## If there is a not second argument, show banner
  [ -n "$2" ] && \
    print "* Checking free space on $ANDROID_ROOT"

  mntspace=$($BB df -m $ANDROID_ROOT | tail -n 1 | tr -s ' ' | cut -d' ' -f4)
  checkspace=$($BB du -c -m $1 | tail -n 1 | awk '{print $1}')

  if [ -z $mntspace ]; then
    print "Warning: Could not get free space status for $ANDROID_ROOT, continuing anyway!"
  elif [ -z $checkspace ]; then
    print "Warning: Could not get free space status for $1, continuing anyway!"
  elif [ "$mntspace" -lt "$checkspace" ]; then
    abort "Warning: Didn't have enough space on $ANDROID_ROOT ($mntspace MB free, need $checkspace MB)"
  elif [ "$mntspace" -eq "0" ]; then
    abort "Warning: Out of space on $ANDROID_ROOT ($mntspace MB free)"
  fi
}

## Start build generated variables
supersu="auto"
## End build generated variables

if [ "$3" ]; then
  ZIPFILE=$3
  console=/proc/$$/fd/$2
  # Write the location of the console buffer to /tmp/console for other scripts to use
  echo "$console" > /tmp/console
else
  console=$(cat /tmp/console)
  [ "$console" ] || console=/proc/$$/fd/1
fi

test "$ANDROID_ROOT" || ANDROID_ROOT=/system
tmp=/tmp/nethunter
patchtmp=$tmp/boot-patcher
export home=$patchtmp
sutmp=/tmp/supersu

print ""
print "##################################################"
print "##                                              ##"
print "##  88      a8P         db        88        88  ##"
print "##  88    .88'         d88b       88        88  ##"
print "##  88   88'          d8''8b      88        88  ##"
print "##  88 d88           d8'  '8b     88        88  ##"
print "##  8888'88.        d8YaaaaY8b    88        88  ##"
print "##  88P   Y8b      d8''''''''8b   88        88  ##"
print "##  88     '88.   d8'        '8b  88        88  ##"
print "##  88       Y8b d8'          '8b 888888888 88  ##"
print "##                                              ##"
print "####  ############# NetHunter ####################"
print ""
print "* NetHunter (BOOTMODE: $BOOTMODE)"
print ""

# Unpack the installer
[ "$ZIPFILE" ] && {
  print "* Unpacking the installer"
  extract "$ZIPFILE" "$tmp" "kalifs-*"
  #print "* Installer unpacked"
}

cd "$tmp"

print "* Loading environment"
#chmod +x env
. ./env.sh

[ -e /dev/block/mapper ] && {
  # Not using abort(), as this is more verbose
  print ""
  print "********** Dynamic Device Detected **********"
  print ""
  print "This Kali NetHunter package cannot be"
  print "installed on this device via recovery"
  print "Please flash this file via Magisk Manager"
  print "as Module and ensure you have USB DEBUGGING"
  print "enabled for using ADB"
  print ""
  print "******* NetHunter Installation failed *******"
  cleanup
  exit 1
}

progress 0.0
print "* Starting the installation"

#------------------------------------------------------------------------------

print "* Setting permissions"
setperm 0755 0755 tools

print "* Setting up BusyBox"
BB=$(get_bb) # Get latest BusyBox
install_recovery_bb

print "* Setting environment"
setup_env # Setup environment for NetHunter installation
SYSTEM="/system"

progress 0.1

#------------------------------------------------------------------------------

[ -d /data/data ] || {
  abort "Your data partition appears to be empty. Please complete the Android setup wizard before installing Kali NetHunter!"
}

print "* Running legacy Kali NetHunter version script" # Checking for previous versions of Kali NetHunter
sh tools/previnstall.sh
#print "* Done checking for previous versions"

progress 0.2

#------------------------------------------------------------------------------

[ -f supersu.zip ] && {
  print "* Extracting SuperSU.zip"
  extract supersu.zip "$sutmp"

  progress 0.3

  print "* Installing SuperSU"
  sh tools/installsu.sh "$sutmp" "$supersu"
  #print "* Done installing SuperSU"
}

progress 0.4

#------------------------------------------------------------------------------

print "* Finding SDK version"
SDK="$(grep 'ro.build.version.sdk' ${SYSTEM}/build.prop | cut -d'=' -f2)"
[ -z $SDK ] && {
  abort "Could not find SDK version"
}
print "*** SDK Version: $SDK"

## Starting with Oreo (Android 8) we can no longer install user apps (/data/app/)
## So we install as system apps (/system)
if [ $SDK -ge 26 ]; then
  ## Apps in /system
  check_freespace $tmp/data/app/ "True"
  print "* Installing apps (via system):"
  installapp_system "NetHunter.apk" "NetHunter"
  installapp_system "NetHunterTerminal.apk" "NetHunter-Terminal" # and NetHunterTerminal.apk because NetHunter.apk depends on it
  installapp_system "NetHunterKeX.apk" "NetHunter-KeX" # and NetHunterKeX.apk because NetHunter.apk depends on it # Disabling as its too large currently on OnePlus???
  installapp_system "NetHunterStore.apk" "NetHunter-Store" # and NetHunterStore.apk because we need it
else
  ## Apps in /data/app/
  check_freespace /data/app/ "True"
  print "Installing apps (via user):"
  installapp_user "NetHunter.apk" "com.offsec.nethunter"
  installapp_user "NetHunterTerminal.apk" "com.offsec.nhterm"         # NetHunter.apk depends on it
  installapp_user "NetHunterKeX.apk" "com.offsec.nethunter.kex"       # NetHunter.apk uses it
  installapp_user "NetHunterStore.apk" "com.offsec.nethunter.store"   # We need it
fi

## Installing privileged extension
installapp_system "NetHunterStorePrivilegedExtension.apk" "NetHunterStorePrivilegedExtension" "priv-app"

if [ $SDK -ge 26 ]; then
  print "* Extracting apps:"

  [ -f ${SYSTEM}/app/NetHunter-Terminal/NetHunterTerminal.apk ] && {
    check_freespace ${SYSTEM}/app/NetHunter-Terminal/
    print "*** Extracting NetHunterTerminal.apk"
    unzip -qo ${SYSTEM}/app/NetHunter-Terminal/NetHunterTerminal.apk "lib/*" -d ${SYSTEM}/app/NetHunter-Terminal/
    ## Some newer TWRP versions ship an unzip that does not support the above line so we might need plan B
    [ -d ${SYSTEM}/app/NetHunter-Terminal/lib ] || {
      print "*** Extracting NetHunterTerminal.apk #2"
      mkdir -p /tmp/NetHunter-Terminal/
      unzip -qo ${SYSTEM}/app/NetHunter-Terminal/NetHunterTerminal.apk -d /tmp/NetHunter-Terminal/
      mv /tmp/NetHunter-Terminal/lib ${SYSTEM}/app/NetHunter-Terminal/
    }
    mv ${SYSTEM}/app/NetHunter-Terminal/lib/armeabi-v7a ${SYSTEM}/app/NetHunter-Terminal/lib/arm
    mv ${SYSTEM}/app/NetHunter-Terminal/lib/arm64-v8a ${SYSTEM}/app/NetHunter-Terminal/lib/arm64
  }

  [ -f ${SYSTEM}/app/NetHunter-KeX/NetHunterKeX.apk ] && {
    check_freespace ${SYSTEM}/app/NetHunter-KeX/
    print "*** Extracting NetHunterKeX.apk"
    unzip -qo ${SYSTEM}/app/NetHunter-KeX/NetHunterKeX.apk "lib/*" -d ${SYSTEM}/app/NetHunter-KeX/
    ## Some newer TWRP versions ship an unzip that does not support the above line so we might need plan B
    [ -d ${SYSTEM}/app/NetHunter-KeX/lib ] || {
      print "*** Extracting NetHunterKeX.apk #2"
      mkdir -p /tmp/NetHunter-KeX/
      unzip -qo ${SYSTEM}/app/NetHunter-KeX/NetHunterKeX.apk -d /tmp/NetHunter-KeX/
      mv /tmp/NetHunter-KeX/lib ${SYSTEM}/app/NetHunter-KeX/
    }
    mv ${SYSTEM}/app/NetHunter-KeX/lib/armeabi-v7a ${SYSTEM}/app/NetHunter-KeX/lib/arm
    mv ${SYSTEM}/app/NetHunter-KeX/lib/arm64-v8a ${SYSTEM}/app/NetHunter-KeX/lib/arm64
  }

  check_freespace ${SYSTEM}/etc/permissions
  print "*** Extracting NetHunterStorePrivilegedExtension.apk"
  mkdir ${SYSTEM}/etc/permissions
  chmod 0755 ${SYSTEM}/etc/permissions
  [ -f system/etc/permissions/com.offsec.nethunter.store.privileged.xml ] && {
    install "/system/etc/permissions/com.offsec.nethunter.store.privileged.xml" 0755 0644 "${SYSTEM}/etc/permissions/com.offsec.nethunter.store.privileged.xml"
  }
fi

progress 0.5

#------------------------------------------------------------------------------

[ -f tools/freespace.sh ] && {
  print "* Running freespace script" # Check for freespace
  # This actually runs twice when the NetHunter kernel zip is included
  sh tools/freespace.sh || abort "Not enough free space on ${SYSTEM} to continue!"
  #print "* Done checking freespace"
}

print "* Running BusyBox installer script"
sh tools/installbusybox.sh
#print "* Done running BusyBox installer"

progress 0.6

#------------------------------------------------------------------------------

[ -d wallpaper ] && {
  print "* Running Kali NetHunter wallpaper script" # Installing Kali NetHunter wallpape
  sh wallpaper/setwallpaper.sh
  #print "* Done installing wallpaper"
}

[ -f system/media/bootanimation.zip ] && {
  print "* Installing Kali NetHunter boot animation"
  install "/system/media/bootanimation.zip" 0755 0644 "${SYSTEM}/media/bootanimation.zip"
}

progress 0.7

#------------------------------------------------------------------------------

[ -d system/etc/nano ] && {
  print "* Copying nano highlights to ${SYSTEM}/etc/nano"
  install "/system/etc/nano" 0755 0644 "${SYSTEM}/etc/nano"
}

[ -d system/etc/terminfo ] && {
  print "* Copying terminfo files to ${SYSTEM}/etc/terminfo"
  install "/system/etc/terminfo" 0755 0644 "${SYSTEM}/etc/terminfo"
}

[ -d system/lib ] && {
  print "* Copying 32-bit shared libraries to ${SYSTEM}/lib"
  install "/system/lib" 0755 0644 "${SYSTEM}/lib"
}

[ -d system/lib64 ] && {
  print "* Copying 64-bit shared libraries to ${SYSTEM}/lib64"
  install "/system/lib64" 0755 0644 "${SYSTEM}/lib64"
}

[ -d system/bin ] && {
  print "* Installing ${SYSTEM}/bin binaries"
  install "/system/bin" 0755 0755 "${SYSTEM}/bin"
}

[ -d system/xbin ] && {
  print "* Installing ${SYSTEM}/xbin binaries"
  [ -d ${SYSTEM}/xbin ] || mkdir -p ${SYSTEM}/xbin
  install "/system/xbin" 0755 0755 "${SYSTEM}/xbin"
}

[ -d data/local ] && {
  print "* Copying additional files to /data/local"
  install "/data/local" 0755 0644
}

[ -d system/etc/init.d ] && {
  print "* Installing init.d scripts"
  install "/system/etc/init.d" 0755 0755 "${SYSTEM}/etc/init.d"

  print "* Installing userinit.d scripts"
  # Create userinit.d and userinit.sh if they don't already exist
  mkdir -p "/data/local/userinit.d"
  setperm 0755 0755 "/data/local/userinit.d"
  [ -f "/data/local/userinit.sh" ] || echo "#!/system/bin/sh" > "/data/local/userinit.sh"
  chmod 0755 "/data/local/userinit.sh"
}

[ -d system/addon.d/80-nethunter.sh ] && {
  print "* Installing ${SYSTEM}/addon.d backup scripts"
  install "/system/80-nethunter.sh" 0755 0755 "${SYSTEM}/80-nethunter.sh"
}

print "* Symlinking Kali boot scripts"
symlink "/data/data/com.offsec.nethunter/files/scripts/bootkali" "${SYSTEM}/bin/bootkali"
symlink "/data/data/com.offsec.nethunter/files/scripts/bootkali_init" "${SYSTEM}/bin/bootkali_init"
symlink "/data/data/com.offsec.nethunter/files/scripts/bootkali_login" "${SYSTEM}/bin/bootkali_login"
symlink "/data/data/com.offsec.nethunter/files/scripts/bootkali_bash" "${SYSTEM}/bin/bootkali_bash"
symlink "/data/data/com.offsec.nethunter/files/scripts/killkali" "${SYSTEM}/bin/killkali"

progress 0.8

#------------------------------------------------------------------------------

[ -d "$patchtmp" ] && {
  print "* Running kernel installer script"
  sh "$patchtmp/META-INF/com/google/android/update-binary"
  #print "* Done running kernel installer"

  print "* Setting environment"
  # Setup environment again (all are restored by boot-patcher)
  setup_env
}

progress 0.9

#------------------------------------------------------------------------------

print "* Running Kali chroot installer script"
sh "$tmp/tools/installchroot.sh" "$ZIPFILE"
#print "* Done running Kali chroot installer"

print "* Restoring environment"
restore_env # Restore environment after installation

print ""
print "##################################################"
print "#        Kali NetHunter is now installed!        #"
print "##################################################"
## This is a work around an Android permission issue
print "#    Please UPDATE the NetHunter app via the     #"
print "#   NetHunter Store before RUNNING it to finish  #"
print "#             setting everything up!             #"
print "##################################################"
print ""

progress 1.0
