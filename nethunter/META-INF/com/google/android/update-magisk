## Kali NetHunter installation script for Magisk (BOOTMODE=true)
## REF: https://github.com/topjohnwu/Magisk/blob/master/scripts/update_binary.sh
##      https://github.com/topjohnwu/Magisk/blob/master/scripts/util_functions.sh

file_getprop() {
  grep "^$2" "$1" | head -n1 | cut -d= -f2-
}

set_perm() {
  chown $2:$3 $1 || return 1
  chmod $4 $1 || return 1
  CON=$5
  [ -z $CON ] && CON=u:object_r:system_file:s0
  chcon $CON $1 || return 1
}

set_perm_recursive() {
  find $1 -type d 2>/dev/null | while read dir; do
    set_perm $dir $2 $3 $4 $6
  done

  find $1 -type f -o -type l 2>/dev/null | while read file; do
    set_perm $file $2 $3 $5 $6
  done
}

symlink() {
  ln -sf "$1" "$2" 2>/dev/null
  chmod 0755 $2 2>/dev/null
}

set_wallpaper() {
  [ -d $TMP/wallpaper ] || return 1
  ui_print "* Installing NetHunter wallpaper"

  # Define wallpaper variables
  wp=/data/system/users/0/wallpaper
  wpinfo=${wp}_info.xml

  # Get screen resolution using wm size
  res=$(wm size | grep "Physical size:" | cut -d' ' -f3 2>/dev/null)
  res_w=$(wm size | grep "Physical size:" | cut -d' ' -f3 | cut -dx -f1 2>/dev/null)
  res_w=$(wm size | grep "Physical size:" | cut -d' ' -f3 | cut -dx -f2 2>/dev/null)

  # Check if we grabbed resolution from wm or not
  [ -z $res_h -o -z $res_w ] && {
    unset res res_h res_w

    # Try to grab the wallpaper height and width from sysfs
    res_w=$(cat /sys/class/drm/*/modes | head -n 1 | cut -f1 -dx)
    res_h=$(cat /sys/class/drm/*/modes | head -n 1 | cut -f2 -dx)

    res="$res_w"x"$res_h" # Resolution size
  }

  [ ! "$res" ] && {
    ui_print "! Can't get screen resolution of device! Skipping."
    return 1
  }

  ui_print "* Found screen resolution: $res"

  [ ! -f "$TMP/wallpaper/$res.png" ] && {
    ui_print "! No wallpaper found for your screen resolution. Skipping."
    return 1
  }

  [ -f "$wp" ] && [ -f "$wpinfo" ] || setup_wp=1

  cat "$TMP/wallpaper/$res.png" > "$wp"
  echo "<?xml version='1.0' encoding='utf-8' standalone='yes' ?>" > "$wpinfo"
  echo "<wp width=\"$res_w\" height=\"$res_h\" name=\"nethunter.png\" />" >> "$wpinfo"

  if [ "$setup_wp" ]; then
    chown system:system "$wp" "$wpinfo"
    chmod 0600 "$wp" "$wpinfo"
    chcon "u:object_r:wallpaper_file:s0" "$wp"
    chcon "u:object_r:system_data_file:s0" "$wpinfo"
  fi

  ui_print "* NetHunter wallpaper applied successfully"
}

f_kill_pids() {
  local lsof_full=$(lsof | awk '{print $1}' | grep -c '^lsof')

  if [ "$lsof_full" -eq 0 ]; then
    local pids=$(lsof | grep "$PRECHROOT" | awk '{print $1}' | uniq)
  else
    local pids=$(lsof | grep "$PRECHROOT" | awk '{print $2}' | uniq)
  fi

  if [ -n "$pids" ]; then
    kill -9 $pids 2> /dev/null
    return $?
  fi

  return 0
}

f_restore_setup() {
  # Set shmmax to 128mb to free memory
  sysctl -w kernel.shmmax=134217728 2>/dev/null

  # Remove all the remaining chroot vnc session pid and log files
  rm -rf $PRECHROOT/tmp/.X11* $PRECHROOT/tmp/.X*-lock $PRECHROOT/root/.vnc/*.pid $PRECHROOT/root/.vnc/*.log > /dev/null 2>&1
}

f_umount_fs() {
  isAllunmounted=0

  if mountpoint -q $PRECHROOT/$1; then
    if umount -f $PRECHROOT/$1; then
      if [ ! "$1" = "dev/pts" -a ! "$1" = "dev/shm" ]; then
        if ! rm -rf $PRECHROOT/$1; then
          isAllunmounted=1
        fi
      fi
    else
      isAllunmounted=1
    fi
  else
    if [ -d $PRECHROOT/$1 ]; then
      if ! rm -rf $PRECHROOT/$1; then
        isAllunmounted=1
      fi
    fi
  fi
}

f_dir_umount() {
  sync

  ui_print "* Killing all running pids"
  f_kill_pids
  f_restore_setup

  ui_print "* Removing all fs mounts"
  for i in "dev/pts" "dev/shm" dev proc sys system; do
    f_umount_fs "$i"
  done

  # Don't force unmount sdcard
  # In some devices, it wipes the internal storage
  if umount -l $PRECHROOT/sdcard; then
    if ! rm -rf $PRECHROOT/sdcard; then
      isAllunmounted=1
    fi
  fi
}

f_is_mntpoint() {
  if [ -d "$PRECHROOT" ]; then
    mountpoint -q "$PRECHROOT" && return 0
    return 1
  fi
}

do_umount() {
  f_is_mntpoint
  res=$?
  case $res in
    1) f_dir_umount;;
    *) return 0;;
  esac

  if [ -z "$(cat /proc/mounts | grep $PRECHROOT)" ]; then
    ui_print "* All done"
    isAllunmounted=0
  else
    ui_print "* There are still mounted points not unmounted yet"
    isAllunmounted=1
  fi

  return $isAllunmounted
}

verify_fs() {
  # Valid architecture?
  case $FS_ARCH in
    armhf|arm64|i386|amd64);;
    *) return 1;;
  esac

  # Valid build size?
  case $FS_SIZE in
    full|minimal|nano);;
    *) return 1;;
  esac

  return 0
}

do_install() {
  ui_print "* Found Kali chroot to be installed: $KALIFS"
  mkdir -p "$NHSYS"

  # HACK 1/2: Rename to kali-(arm64,armhf,amd64,i386) as NetHunter app supports searching these directory after first boot
  CHROOT="$NHSYS/kali-$FS_ARCH" # Legacy rootfs directory prior to 2020.1
  ROOTFS="$NHSYS/kalifs"        # New symlink allowing to swap chroots via NetHunter app on the fly
  PRECHROOT=$( find /data/local/nhsystem -type d -iname kali-* | head -n 1 ) # Previous chroot location

  # Remove previous chroot
  [ -d "$PRECHROOT" ] && {
    ui_print "* Previous chroot detected!"
    do_umount
    [ $? == 1 ] && {
      ui_print "! Aborting chroot installations"
      ui_print "* Remove the previous chroot and install the new chroot via NetHunter app"
      return 1
    }

    ui_print "* Removing previous chroot"
    rm -rf "$PRECHROOT"
    rm -f "$ROOTFS"
  }

  # Extract new chroot
  ui_print "* Extracting Kali rootfs (This may take up to 25 minutes)"
  unzip -p "$ZIPFILE" "$KALIFS" | tar -xJf - -C "$NHSYS" --exclude "kali-$FS_ARCH/dev"

  [ $? = 0 ] || {
    ui_print "! Error: Kali $FS_ARCH $FS_SIZE chroot failed to install!"
    ui_print "* Maybe you ran out of space on your data partition?"
    return 1
  }

  # HACK 2/2: Create a link to be used by apps effective 2020.1
  ln -sf "$CHROOT" "$ROOTFS"
  mkdir -m 0755 "$CHROOT/dev"
  ui_print "* Kali $FS_ARCH $FS_SIZE chroot installed successfully!"

  # We should remove the rootfs archive to free up device memory or storage space (if not zip install)
  [ "$1" ] || rm -f "$KALIFS"

  return 0
}

do_flash() {
  ui_print "* Found Kali kernel to be installed: $KERNEL"
  unzip -p "$ZIPFILE" "$KERNEL" > "$KERNEL"
  $MAGISKBB source $TMP/tools/magic-flash.sh $KERNEL | awk '!/    ui_print/ && !/inflating/ && gsub(/ui_print/,"")'   # Don't use sh over source
}

flash_kernel() {
  # Check zip for kernel-*.zip first
  [ -e "$ZIPFILE" ] && {
    KERNEL=$(unzip -lqq "$ZIPFILE" | awk '$4 ~ /^kernel-/ { print $4; exit }')
    # Check other locations if zip didn't contain a kernel-*.zip
    [ "$KERNEL" ] || {
      ui_print "* No kernel found. Skipping."
      return
    }
    do_flash
  }
}

do_chroot() {
  # Chroot common path
  NHSYS=/data/local/nhsystem

  # do_install [optional zip containing kalifs chroot/rootfs]
  # Check zip for kalifs-* first
  [ -e "$ZIPFILE" ] && {
    KALIFS=$(unzip -lqq "$ZIPFILE" | awk '$4 ~ /^kalifs-/ { print $4; exit }')
    # Check other locations if zip didn't contain a kalifs-*
    [ "$KALIFS" ] || {
      ui_print "* No Kali rootfs found. Skipping."
      return
    }

    FS_SIZE=$(echo "$KALIFS" | awk -F[-.] '{print $2}')
    FS_ARCH=$(echo "$KALIFS" | awk -F[-.] '{print $3}')
    verify_fs && do_install
  }
}

require_new_magisk() {
  echo "*******************************"
  echo " Please install Magisk v20.4+! "
  echo "*******************************"
  exit 1
}

#------------------------------------------------------------------------------

#<REF: ./scripts/module_installer.sh>
#################
# Initialization
#################
umask 022

#########################
# Load util_functions.sh
#########################
OUTFD=$2
ZIPFILE=$3

mount /data 2>/dev/null

[ -f /data/adb/magisk/util_functions.sh ] || require_new_magisk
source /data/adb/magisk/util_functions.sh
[ $MAGISK_VER_CODE -lt 20400 ] && require_new_magisk
#</ REF: ./scripts/module_installer.sh>

#<REF: ./scripts/util_functions.sh>
#########################
# Install module
#########################
rm -rf $TMPDIR
mkdir -p $TMPDIR
chcon u:object_r:system_file:s0 $TMPDIR
cd $TMPDIR

setup_flashable
mount_partitions
api_level_arch_detect

# Setup BusyBox and binaries
boot_actions

# Extract prop file
unzip -oj "$ZIPFILE" tools/module.prop -d $TMPDIR >&2
[ ! -f $TMPDIR/module.prop ] && abort "! Unable to extract zip file!"

MODDIRNAME=modules_update
MODULEROOT=/data/adb/$MODDIRNAME
MODID=$(grep_prop id $TMPDIR/module.prop)
MODNAME=$(grep_prop name $TMPDIR/module.prop)
MODAUTH=$(grep_prop author $TMPDIR/module.prop)
MODPATH=$MODULEROOT/$MODID

# Create mod paths
rm -rf $MODPATH
mkdir -p $MODPATH || abort "! Unable to: mkdir -p $MODPATH"
#</ REF: ./scripts/util_functions.sh>

# Define several variables
[ -z $TMPDIR ] && TMPDIR=/dev/tmp
[ ! -z $ZIP ] && { ZIPFILE="$ZIP"; unset ZIP; }
[ -z $ZIPFILE ] && ZIPFILE="$3"
DIR=$(dirname "$ZIPFILE")
TMP=$TMPDIR/$MODID

# Magisk manager/booted flashing support
[ -e /data/adb/magisk ] && ADB=adb
OUTFD=/proc/self/fd/0
if [ -e /data/$ADB/magisk ]; then
  [ -e /magisk/.core/busybox ] && MAGISKBB=/magisk/.core/busybox
  [ -e /sbin/.core/busybox ] && MAGISKBB=/sbin/.core/busybox
  [ -e /sbin/.magisk/busybox ] && MAGISKBB=/sbin/.magisk/busybox
  [ -e /dev/*/.magisk/busybox ] && MAGISKBB=$(echo /dev/*/.magisk/busybox)
  [ "$MAGISKBB" ] && export PATH="$MAGISKBB:$PATH"
fi

# Define modules target dirs
if [ -e /data/adb/modules ]; then
  MNT=/data/adb/modules_update
  MAGISK=/$MODID/system
fi

# Set target paths
[ ! -z $MODPTH ] || MODPATH=$MNT/$MODID
TARGET=$MNT$MAGISK
ETC=$TARGET/etc
BIN=$TARGET/bin

if [ -d /system/xbin ]; then
  XBIN=$TARGET/xbin
else
  XBIN=$TARGET/bin
fi

if [ -d /system/media ]; then
  MEDIA=$TARGET/media
elif [ -d /system/product/media ]; then
  MEDIA=$TARGET/product/media
fi

UMASK=$(umask)
umask 022

#------------------------------------------------------------------------------

# Ensure zip installer shell is in a working scratch directory
mkdir -p $TMPDIR
cd $TMPDIR

# Source custom installer functions and configuration
unzip -jo "$ZIPFILE" tools/module.prop -d $TMPDIR >&2
MODID=$(file_getprop module.prop id)

# Extract the installer
ui_print "* Unpacking the installer"
mkdir -p $TMPDIR/$MODID
cd $TMPDIR/$MODID
## Unpack the installer (everything but "kalifs-*")
unzip -qq "$ZIPFILE" -x "kalifs-*"
#ui_print "* Installer unpacked"

#------------------------------------------------------------------------------

# Setup environment before installations
# Mount System as r/w just incase we need it
ui_print "* Setting environment"
DYNAMIC=false
SAR=false
if [ -d /dev/block/mapper ]; then
  for block in system; do
    for slot in "" _a _b; do
      blockdev --setrw /dev/block/mapper/$block$slot 2>/dev/null
    done
  done
  DYNAMIC=true
fi
mount -o rw,remount -t auto /system || mount /system
[ $? != 0 ] && mount -o rw,remount -t auto / && SAR=true

# Additional setup for installing apps via pm
[[ "$(getenforce)" == "Enforcing" ]] && ENFORCE=true || ENFORCE=false
$ENFORCE && setenforce 0
VERIFY=$(settings get global verifier_verify_adb_installs)
settings put global verifier_verify_adb_installs 0

#------------------------------------------------------------------------------

# Uninstall previous apps and binaries module if they are installed
ui_print "* Checking for previous version of NetHunter apps and files"
pm uninstall com.offsec.nethunter &> /dev/null
pm uninstall com.offsec.nethunter.kex &> /dev/null
pm uninstall com.offsec.nhterm &> /dev/null
pm uninstall com.offsec.nethunter.store &> /dev/null

# Remove Osmosis BusyBox module
[ -d /data/adb/modules/busybox-ndk ] && {
  # Follow Magisk way to disable and remove modules
  touch /data/adb/modules/busybox-ndk/disable
  touch /data/adb/modules/busybox-ndk/remove
}

# Remove Wi-Fi firmware modules
[ -d /data/adb/modules/wirelessFirmware ] && {
  # Follow Magisk way to disable and remove modules
  touch /data/adb/modules/wirelessFirmware/disable
  touch /data/adb/modules/wirelessFirmware/remove
}

# Remove nano modules
[ -d /data/adb/modules/nano-ndk ] && {
  # Follow Magisk way to disable and remove modules
  touch /data/adb/modules/nano-ndk/disable
  touch /data/adb/modules/nano-ndk/remove
}

#------------------------------------------------------------------------------

[ -e "$ZIPFILE" ] && {
  ZIP=$(unzip -lqq "$ZIPFILE" | awk '$4 ~ /^supersu.zip/ { print $4; exit }')
  [ "$ZIP" ] && {
    ui_print "* [!] SuperSU.zip is not supported with Magisk"
  }
}

#------------------------------------------------------------------------------

# Install all NetHunter apps
# `/system/bin/pm` is an helper-script for `/system/bin/cmd package`

ui_print "* Installing apps (via system):"

# Install the core NetHunter app
ui_print "*** Installing NetHunter.apk"
pm install $TMP/data/app/NetHunter.apk &>/dev/null

# NetHunter.apk depends on it
ui_print "*** Installing NetHunterTerminal.apk"
pm install $TMP/data/app/NetHunterTerminal.apk &>/dev/null

# NetHunter.apk uses it
ui_print "*** Installing NetHunter-KeX.apk"
pm install $TMP/data/app/NetHunterKeX.apk &>/dev/null

# We need it
ui_print "*** Installing NetHunter-Store.apk"
pm install -g $TMP/data/app/NetHunterStore.apk &>/dev/null

# NetHunterStore.apk depends on it
ui_print "*** Installing NetHunterStorePrivilegedExtension.apk"
pm install -g $TMP/data/app/NetHunterStorePrivilegedExtension.apk &>/dev/null

#ui_print "* Done installing apps"

#------------------------------------------------------------------------------

# Install BusyBox
ui_print "* Setting up BusyBox"
[ -f $TMP/tools/install-busybox-magisk.sh ] && source $TMP/tools/install-busybox-magisk.sh   # Don't use sh over source
#print "* Done installing BusyBox"

#------------------------------------------------------------------------------

# Setup Kali NetHunter wallpaper of correct resolution if there is one available
set_wallpaper || ui_print "[!] Failed to set wallpaper"

#------------------------------------------------------------------------------

# Install NetHunter boot animation
[ -f $TMP/system/media/bootanimation.zip ] && {
  ui_print "* Installing Kali NetHunter boot animation"
  mkdir -p $MEDIA
  cp $TMP/system/media/bootanimation.zip $MEDIA
}

# Install required firmwares, binaries, lib files for Kali NetHunter
[ -d $TMP/system/etc/nano ] && {
  ui_print "* Copying nano highlights to /system/etc/nano"
  mkdir -p $ETC
  cp -r "$TMP/system/etc/nano" "$ETC/"
  set_perm_recursive "$ETC/nano" 0 0 0755 0644
}

[ -d $TMP/system/etc/terminfo ] && {
  ui_print "* Copying terminfo files to /system/etc/terminfo"
  mkdir -p $ETC
  cp -r "$TMP/system/etc/terminfo" "$ETC/"
  set_perm_recursive "$ETC/terminfo" 0 0 0755 0644
}

[ -d $TMP/boot-patcher/system/etc/firmware ] && {
  ui_print "* Copying Wi-Fi firmwares to /system/etc/firmware"
  mkdir -p $ETC
  cp -r "$TMP/boot-patcher/system/etc/firmware" "$ETC/"
  set_perm_recursive "$ETC/firmware" 0 0 0755 0644
}

[ -d $TMP/system/lib ] && {
  ui_print "* Copying 32-bit shared libraries to /system/lib"
  cp -r "$TMP/system/lib" "$TARGET/"
  set_perm_recursive "$TARGET/lib" 0 0 0755 0644
}

[ -d $TMP/system/lib64 ] && {
  ui_print "* Copying 64-bit shared libraries to /system/lib64"
  cp -r "$TMP/system/lib64" "$TARGET/"
  set_perm_recursive "$TARGET/lib64" 0 0 0755 0644
}

[ -d $TMP/system/bin ] && {
  ui_print "* Installing /system/bin binaries"
  cp -r "$TMP/system/bin" "$TARGET/"
  set_perm_recursive "$BIN" 0 0 0755 0755
}

[ -d $TMP/boot-patcher/system/xbin ] && {
  ui_print "* Installing hid-keyboard to /system/xbin"
  cp -r $TMP/boot-patcher/system/xbin/* "$XBIN/"
  set_perm_recursive "$XBIN" 0 0 0755 0755
}

[ -d $TMP/data/local ] && {
  ui_print "* Copying additional files to /data/local"
  mkdir -p /data/local
  cp -r $TMP/data/local/* "/data/local/"
  set_perm_recursive "/data/local" 0 0 0755 0644
}

[ -d $TMP/system/etc/init.d ] && {
  ui_print "* Installing init.d scripts"
  cp -r "$TMP/system/etc/init.d" "$ETC/"

  # Create userinit.d and userinit.sh if they don't already exist
  ui_print "* Installing userinit.d scripts"
  rm -rf /data/local/userinit.d # Remove previous one
  mkdir -p "/data/local/userinit.d"
  [ -f "/data/local/userinit.sh" ] || echo "#!/system/bin/sh" > "/data/local/userinit.sh"
  chmod 0755 "/data/local/userinit.sh"
  set_perm_recursive "$ETC/init.d" 0 0 0755 0644
}

[ -e $TMP/system/addon.d/80-nethunter.sh ] && {
  ui_print "* Installing /system/addon.d backup scripts"
  mkdir -p "$TARGET/addon.d"
  cp "$TMP/system/addon.d/80-nethunter.sh" "$TARGET/"
  cp "$TMP/system/addon.d/80-nethunter.sh" "$TARGET/addon.d/"
  set_perm_recursive "$TARGET/addon.d" 0 0 0755 0644
}

#------------------------------------------------------------------------------

# Symlink bootkali* scripts for using in another terminals
# May need to start up NetHunter.apk first!
ui_print "* Symlinking NetHunter.apk boot scripts"
if [ -e /data/data/com.offsec.nethunter/assets/scripts/ ]; then
  symlink "/data/data/com.offsec.nethunter/assets/scripts/bootkali" "$TARGET/bin/bootkali" || ui_print "[!] Missing bootkali"
  symlink "/data/data/com.offsec.nethunter/assets/scripts/bootkali_init" "$TARGET/bin/bootkali_init" || ui_print "[!] Missing bootkali_init"
  symlink "/data/data/com.offsec.nethunter/assets/scripts/bootkali_login" "$TARGET/bin/bootkali_login" || ui_print "[!] Missing bootkali_login"
  symlink "/data/data/com.offsec.nethunter/assets/scripts/bootkali_bash" "$TARGET/bin/bootkali_bash" || ui_print "[!] Missing bootkali_bash"
  symlink "/data/data/com.offsec.nethunter/assets/scripts/killkali" "$TARGET/bin/killkali" || ui_print "[!] Missing killkali"
else
  ui_print "[!] Magisk doesn't have permission to access"
fi
set_perm_recursive "$BIN" 0 0 0755 0755

#------------------------------------------------------------------------------

# Adding required permissions for NetHunter app
ui_print "* Granting required permissions to NetHunter app"
source $TMP/tools/apk-permissions.sh || ui_print "[!] Failed to set permissions"   # Don't use sh over source
#print "* Done setting permissions to NetHunter app"

#------------------------------------------------------------------------------

# Install kernel
ui_print "* Flashing kernel"
flash_kernel || ui_print "[!] Failed to flash kernel"

#------------------------------------------------------------------------------

# Install chroot
ui_print "* Installing chroot"
do_chroot || ui_print "[!] Failed to install chroot"

#------------------------------------------------------------------------------

# Random important Magisk stuff (Don't remove)
ui_print "* Important Magisk items"
cp -fp $TMP/tools/module.prop $MNT/$MODID/
touch $MNT/$MODID/auto_mount
[ -e /data/adb/modules ] && IMGMNT=/data/adb/modules
mkdir -p "$IMGMNT/$MODID"
touch "$IMGMNT/$MODID/update"
cp -fp $TMP/tools/module.prop "$IMGMNT/$MODID/"

#------------------------------------------------------------------------------

ui_print "* Restoring environment"
cd /

# Restore environment after installations
if [ -d /dev/block/mapper ]; then
  for block in system; do
    for slot in "" _a _b; do
      blockdev --setro /dev/block/mapper/$block$slot 2>/dev/null
    done
  done
fi
[ "$SAR" ] && mount -o ro,remount -t auto / || mount -o ro,remount -t auto /system

# Restore also additional settings we did before
settings put global verifier_verify_adb_installs $VERIFY
$ENFORCE && setenforce 1

# Handle replace folders
for TARGET in $REPLACE; do
  ui_print "* Replace target: $TARGET"
  mktouch $MODPATH$TARGET/.replace
done

#------------------------------------------------------------------------------

# Clean up
ui_print "* Cleaning up"
rm -rf $TMPDIR
umask $UMASK

# Done

#------------------------------------------------------------------------------

#<REF: ./scripts/util_functions.sh>
# Update info for Magisk manager
print "* Setting Magisk metadata"
mktouch /data/adb/modules/$MODID/update
rm -rf /data/adb/modules/$MODID/remove 2>/dev/null
rm -rf /data/adb/modules/$MODID/disable 2>/dev/null
cp -af $MODPATH/module.prop /data/adb/modules/$MODID/module.prop

# Copy over custom sepolicy rules
if [ -f $MODPATH/sepolicy.rule ]; then
  print "* Installing custom sepolicy rules"
  copy_preinit_files
fi

# Remove stuff that doesn't belong to modules and clean up any empty directories
rm -rf $MODPATH/update-magisk \
       $MODPATH/system/placeholder \
       $MODPATH/customize.sh \
       $MODPATH/README.md \
       $MODPATH/.git*
#rmdir -p $MODPATH 2>/dev/null

cd /
rm -rf $TMPDIR
#</ REF: ./scripts/util_functions.sh>
