## [Magisk] [nethunter] [This is sourced, not a standalone script]
## Kali NetHunter installation script for Magisk
## REF: https://github.com/topjohnwu/Magisk/blob/master/scripts/update_binary.sh
##      https://github.com/topjohnwu/Magisk/blob/master/scripts/util_functions.sh

symlink() {
  ln -sf "$1" "$2" 2>/dev/null
  chmod 0755 $2 2>/dev/null
}

f_kill_pids() {
  local lsof_full=$(lsof | awk '{print $1}' | grep -c '^lsof')

  if [ "$lsof_full" -eq 0 ]; then
    local pids=$(lsof | grep "$PRECHROOT" | awk '{print $1}' | uniq)
  else
    local pids=$(lsof | grep "$PRECHROOT" | awk '{print $2}' | uniq)
  fi

  if [ -n "$pids" ]; then
    kill -9 $pids 2> /dev/null
    return $?
  fi

  return 0
}

f_restore_setup() {
  ## Set shmmax to 128mb to free memory
  sysctl -w kernel.shmmax=134217728 2>/dev/null

  ## Remove all the remaining chroot vnc session pid and log files
  rm -rf $PRECHROOT/tmp/.X11* $PRECHROOT/tmp/.X*-lock $PRECHROOT/root/.vnc/*.pid $PRECHROOT/root/.vnc/*.log > /dev/null 2>&1
}

f_umount_fs() {
  isAllunmounted=0

  if mountpoint -q $PRECHROOT/$1; then
    if umount -f $PRECHROOT/$1; then
      if [ ! "$1" = "dev/pts" -a ! "$1" = "dev/shm" ]; then
        if ! rm -rf $PRECHROOT/$1; then
          isAllunmounted=1
        fi
      fi
    else
      isAllunmounted=1
    fi
  else
    if [ -d $PRECHROOT/$1 ]; then
      if ! rm -rf $PRECHROOT/$1; then
        isAllunmounted=1
      fi
    fi
  fi
}

f_dir_umount() {
  sync

  ui_print "* Killing all running pids"
  f_kill_pids
  f_restore_setup

  ui_print "* Removing all fs mounts"
  for i in "dev/pts" "dev/shm" dev proc sys system; do
    f_umount_fs "$i"
  done

  ## Don't force unmount SDcard
  ##   In some devices, it wipes the internal storage
  if mount | grep -q "$PRECHROOT/sdcard"; then
    if umount -l $PRECHROOT/sdcard; then
        if ! rm -rf $PRECHROOT/sdcard; then
        isAllunmounted=1
      fi
    fi
  fi
}

f_is_mntpoint() {
  if [ -d "$PRECHROOT" ]; then
    mountpoint -q "$PRECHROOT" && return 0
    return 1
  fi
}

do_umount() {
  f_is_mntpoint
  res=$?
  case $res in
    1) f_dir_umount;;
    *) return 0;;
  esac

  if [ -z "$(cat /proc/mounts | grep $PRECHROOT)" ]; then
    ui_print "* All done"
    isAllunmounted=0
  else
    ui_print "* There are still mounted points not unmounted yet"
    isAllunmounted=1
  fi

  return $isAllunmounted
}

verify_fs() {
  ## Valid architecture?
  case $FS_ARCH in
    armhf|arm64|i386|amd64);;
    *) return 1;;
  esac

  ## Valid build size?
  case $FS_SIZE in
    full|minimal|nano);;
    *) return 1;;
  esac

  return 0
}

do_install() {
  ui_print "* Found Kali chroot to be installed: $KALIFS"
  mkdir -p "$NHSYS"

  ## HACK 1/2: Rename to kali-(arm64,armhf,amd64,i386) as NetHunter app supports searching these directory after first boot
  CHROOT="$NHSYS/kali-$FS_ARCH" # Legacy rootfs directory prior to 2020.1
  ROOTFS="$NHSYS/kalifs"        # New symlink allowing to swap chroots via NetHunter app on the fly
  PRECHROOT=$( find /data/local/nhsystem -type d -iname kali-* | head -n 1 ) # Previous chroot location

  ## Remove previous chroot
  [ -d "$PRECHROOT" ] && {
    ui_print "* Previous chroot detected!"
    do_umount
    [ $? == 1 ] && {
      ui_print "! Aborting chroot installations"
      ui_print "* Remove the previous chroot and install the new chroot via NetHunter app"
      return 1
    }

    ui_print "* Removing previous chroot"
    rm -rf "$PRECHROOT"
    rm -f "$ROOTFS"
  }

  ## Extract new chroot
  ui_print "* Extracting Kali rootfs (This may take up to 25 minutes)"
  unzip -p "$ZIPFILE" "$KALIFS" | tar -xJf - -C "$NHSYS" --exclude "kali-$FS_ARCH/dev"

  [ $? = 0 ] || {
    ui_print "! Error: Kali $FS_ARCH $FS_SIZE chroot failed to install!"
    ui_print "* Maybe you ran out of space on your data partition?"
    return 1
  }

  ## HACK 2/2: Create a link to be used by apps effective 2020.1
  ln -sf "$CHROOT" "$ROOTFS"
  mkdir -pv -m 0755 "$CHROOT/dev"
  ui_print "* Kali $FS_ARCH $FS_SIZE chroot installed successfully!"

  ## We should remove the rootfs archive to free up device memory or storage space (if not zip install)
  [ "$1" ] || rm -f "$KALIFS"

  return 0
}

do_flash() {
  ui_print "* Found Kali kernel to be installed: $KERNEL"
  unzip -p "$ZIPFILE" "$KERNEL" > "$KERNEL"
  out=$(sh $TMP/tools/magic-flash.sh $KERNEL)    # Spawn a new session (aka using sh), don't in current session (able to pass variables/functions)
  ret=$?   # We want magic-flash.sh exit code, not awk!
  echo "$out" | awk 'gsub(/ui_print /," ") && !/^ $/' # Replace ui_print, to indent output (to signal its a script), remove empty lines and banner
  [ "$ret" -eq 0 ] || abort "! magic-flash.sh failed"
}

flash_kernel() {
  [ -e "$ZIPFILE" ] && {
    ## Check zip for kernel-*.zip first
    KERNEL=$(unzip -lqq "$ZIPFILE" | awk '$4 ~ /^kernel-/ { print $4; exit }')
    ## If zip didn't contain a kernel-*.zip
    [ "$KERNEL" ] || {
      ui_print "* No kernel found. Skipping"
      return
    }
    do_flash
  }
}

do_chroot() {
  ## Chroot common path
  NHSYS=/data/local/nhsystem

  ## do_install [optional zip containing kalifs chroot/rootfs]
  [ -e "$ZIPFILE" ] && {
    ## Check zip for kalifs-* first
    KALIFS=$(unzip -lqq "$ZIPFILE" | awk '$4 ~ /^kalifs-/ { print $4; exit }')
    ## If zip didn't contain a kalifs-*
    [ "$KALIFS" ] || {
      ui_print "* No Kali rootfs found. Skipping"
      return
    }

    FS_SIZE=$(echo "$KALIFS" | awk -F[-.] '{print $2}')
    FS_ARCH=$(echo "$KALIFS" | awk -F[-.] '{print $3}')
    verify_fs && do_install
  }
}

#------------------------------------------------------------------------------

#<REF: ./scripts/util_functions.sh>
#########################
# Install module
#########################
rm -rf $TMPDIR
mkdir -p $TMPDIR
chcon u:object_r:system_file:s0 $TMPDIR
cd $TMPDIR

setup_flashable
mount_partitions
api_level_arch_detect

## Setup BusyBox and binaries
boot_actions

# Extract prop file
unzip -o "$ZIPFILE" module.prop -d $TMPDIR >&2
[ ! -f $TMPDIR/module.prop ] && abort "! Unable to extract zip file!"

MODDIRNAME=modules_update
MODULEROOT=/data/adb/$MODDIRNAME
MODID=$(grep_prop id $TMPDIR/module.prop)
MODNAME=$(grep_prop name $TMPDIR/module.prop)
MODAUTH=$(grep_prop author $TMPDIR/module.prop)
MODPATH=$MODULEROOT/$MODID

## Create mod paths
rm -rf $MODPATH
mkdir -p $MODPATH || abort "! Unable to: mkdir -p $MODPATH"
#</REF: ./scripts/util_functions.sh>

## Define several variables
[ -z $TMPDIR ] && TMPDIR=/dev/tmp
[ -n $ZIP ] && { ZIPFILE="$ZIP"; unset ZIP; }
[ -z $ZIPFILE ] && ZIPFILE="$3"
DIR=$(dirname "$ZIPFILE")
TMP=$TMPDIR/$MODID

## Magisk manager/booted flashing support
OUTFD=/proc/self/fd/0
[ -e /data/adb/magisk ] && ADB=adb
if [ -e /data/$ADB/magisk ]; then
  [ -e /magisk/.core/busybox ] && MAGISKBB=/magisk/.core/busybox
  [ -e /sbin/.core/busybox ] && MAGISKBB=/sbin/.core/busybox
  [ -e /sbin/.magisk/busybox ] && MAGISKBB=/sbin/.magisk/busybox
  [ -e /dev/*/.magisk/busybox ] && MAGISKBB=$(echo /dev/*/.magisk/busybox)
  [ "$MAGISKBB" ] && export PATH="$MAGISKBB:$PATH"
fi

## Define modules target dirs
if [ -e /data/adb/modules ]; then
  MNT=/data/adb/modules_update
  MAGISK=/$MODID/system
fi

## Set target paths
[ ! -z $MODPTH ] || MODPATH=$MNT/$MODID
TARGET=$MNT$MAGISK
ETC=$TARGET/etc
BIN=$TARGET/bin

if [ -d /system/xbin ]; then
  XBIN=$TARGET/xbin
else
  XBIN=$TARGET/bin
fi

if [ -d /system/media ]; then
  MEDIA=$TARGET/media
elif [ -d /system/product/media ]; then
  MEDIA=$TARGET/product/media
fi

UMASK=$(umask)
umask 022

#------------------------------------------------------------------------------

## Ensure zip installer shell is in a working scratch directory
mkdir -p $TMPDIR
cd $TMPDIR

# Source custom installer functions and configuration
#unzip -o "$ZIPFILE" module.prop -d $TMPDIR >&2
#MODID=$(file_getprop module.prop id) # Alt: MODID=$(grep_prop id $TMPDIR/module.prop)

## Extract the ZIP
ui_print "* Unpacking ZIP"
mkdir -p $TMPDIR/$MODID
cd $TMPDIR/$MODID
## Unpack the ZIP (everything but "kalifs-*")
unzip -qq "$ZIPFILE" -x "kalifs-*"
#ui_print "* ZIP unpacked"

#------------------------------------------------------------------------------

## Setup environment before installations
##   Mount System as r/w just incase we need it
ui_print "* Setting environment"
DYNAMIC=false
SAR=false
if [ -d /dev/block/mapper ]; then
  for block in system; do
    for slot in "" _a _b; do
      blockdev --setrw /dev/block/mapper/$block$slot 2>/dev/null
    done
  done
  DYNAMIC=true
fi
mount -o rw,remount -t auto /system || mount /system
[ $? != 0 ] && mount -o rw,remount -t auto / && SAR=true

## Additional setup for installing apps via pm
[[ "$(getenforce)" == "Enforcing" ]] && ENFORCE=true || ENFORCE=false
$ENFORCE && setenforce 0
VERIFY=$(settings get global verifier_verify_adb_installs)
settings put global verifier_verify_adb_installs 0

#------------------------------------------------------------------------------

# Uninstall previous apps and binaries module if they are installed
ui_print "* Checking for previous version of NetHunter apps and files"
pm uninstall com.offsec.nethunter &> /dev/null
pm uninstall com.offsec.nethunter.kex &> /dev/null
pm uninstall com.offsec.nhterm &> /dev/null
pm uninstall com.offsec.nethunter.store &> /dev/null

## Remove Osmosis BusyBox module
[ -d /data/adb/modules/busybox-ndk ] && {
  ## Follow Magisk way to disable and remove modules
  touch /data/adb/modules/busybox-ndk/disable
  touch /data/adb/modules/busybox-ndk/remove
}

## Remove Wi-Fi firmware modules
[ -d /data/adb/modules/wirelessFirmware ] && {
  ## Follow Magisk way to disable and remove modules
  touch /data/adb/modules/wirelessFirmware/disable
  touch /data/adb/modules/wirelessFirmware/remove
}

## Remove nano modules
[ -d /data/adb/modules/nano-ndk ] && {
  ## Follow Magisk way to disable and remove modules
  touch /data/adb/modules/nano-ndk/disable
  touch /data/adb/modules/nano-ndk/remove
}

#------------------------------------------------------------------------------

[ -e "$ZIPFILE" ] && {
  ZIP=$(unzip -lqq "$ZIPFILE" | awk '$4 ~ /^supersu.zip/ { print $4; exit }')
  [ "$ZIP" ] && {
    ui_print "* [!] SuperSU.zip is not supported with Magisk"
  }
}

#------------------------------------------------------------------------------

## Install all NetHunter apps
##   `/system/bin/pm` is an helper-script for `/system/bin/cmd package`

ui_print "* Installing apps (via system):"

# Install the core NetHunter app
ui_print "** Installing NetHunter.apk"
pm install $TMP/data/app/NetHunter.apk &>/dev/null

# NetHunter.apk depends on it
ui_print "** Installing NetHunterTerminal.apk"
pm install $TMP/data/app/NetHunterTerminal.apk &>/dev/null

# NetHunter.apk uses it
ui_print "** Installing NetHunterKeX.apk"
pm install $TMP/data/app/NetHunterKeX.apk &>/dev/null

# We need it
ui_print "** Installing NetHunterStore.apk"
pm install -g $TMP/data/app/NetHunterStore.apk &>/dev/null

# NetHunterStore.apk depends on it
ui_print "** Installing NetHunterStorePrivilegedExtension.apk"
pm install -g $TMP/data/app/NetHunterStorePrivilegedExtension.apk &>/dev/null

#ui_print "* Done installing apps"

#------------------------------------------------------------------------------

## Install BusyBox
ui_print "* Setting up BusyBox"
source $TMP/tools/install-busybox.sh || abort "! install-busybox.sh"   # Don't spawn a new session (aka using sh), do in current session (able to pass variables/functions)
#print "* Done installing BusyBox"

#------------------------------------------------------------------------------

## Setup Kali NetHunter wallpaper of correct resolution if there is one available
if [ -d $TMP/wallpaper ]; then
  ui_print "* Running Kali NetHunter wallpaper script" # Installing Kali NetHunter wallpaper
  source $TMP/tools/set-wallpaper.sh || abort "! set-wallpaper.sh"   # Don't spawn a new session (aka using sh), do in current session (able to pass variables/functions)
else
  ui_print "- Skipping wallpaper"
fi

#------------------------------------------------------------------------------

## Install NetHunter boot animation
[ -f $TMP/system/media/bootanimation.zip ] && {
  ui_print "* Installing Kali NetHunter boot animation"
  mkdir -p $MEDIA
  cp $TMP/system/media/bootanimation.zip $MEDIA
}

## Install required firmwares, binaries, lib files for Kali NetHunter
[ -d $TMP/system/etc/nano ] && {
  ui_print "* Copying nano highlights to /system/etc/nano"
  mkdir -p $ETC
  cp -r "$TMP/system/etc/nano" "$ETC/"
  set_perm_recursive "$ETC/nano" 0 0 0755 0644
}

[ -d $TMP/system/etc/terminfo ] && {
  ui_print "* Copying terminfo files to /system/etc/terminfo"
  mkdir -p $ETC
  cp -r "$TMP/system/etc/terminfo" "$ETC/"
  set_perm_recursive "$ETC/terminfo" 0 0 0755 0644
}

[ -d $TMP/boot-patcher/system/etc/firmware ] && {
  ui_print "* Copying Wi-Fi firmwares to /system/etc/firmware"
  mkdir -p $ETC
  cp -r "$TMP/boot-patcher/system/etc/firmware" "$ETC/"
  set_perm_recursive "$ETC/firmware" 0 0 0755 0644
}

[ -d $TMP/system/lib ] && {
  ui_print "* Copying 32-bit shared libraries to /system/lib"
  cp -r "$TMP/system/lib" "$TARGET/"
  set_perm_recursive "$TARGET/lib" 0 0 0755 0644
}

[ -d $TMP/system/lib64 ] && {
  ui_print "* Copying 64-bit shared libraries to /system/lib64"
  cp -r "$TMP/system/lib64" "$TARGET/"
  set_perm_recursive "$TARGET/lib64" 0 0 0755 0644
}

[ -d $TMP/system/bin ] && {
  ui_print "* Installing /system/bin binaries"
  cp -r "$TMP/system/bin" "$TARGET/"
  set_perm_recursive "$BIN" 0 0 0755 0755
}

[ -d $TMP/boot-patcher/system/xbin ] && {
  ui_print "* Installing hid-keyboard to /system/xbin"
  cp -r $TMP/boot-patcher/system/xbin/* "$XBIN/"
  set_perm_recursive "$XBIN" 0 0 0755 0755
}

[ -d $TMP/data/local ] && {
  ui_print "* Copying additional files to /data/local"
  mkdir -p /data/local
  cp -r $TMP/data/local/* "/data/local/"
  set_perm_recursive "/data/local" 0 0 0755 0644
}

[ -d $TMP/system/etc/init.d ] && {
  ui_print "* Installing init.d scripts"
  cp -r "$TMP/system/etc/init.d" "$ETC/"

  ## Create userinit.d and userinit.sh if they don't already exist
  ui_print "* Installing userinit.d scripts"
  rm -rf /data/local/userinit.d # Remove previous one
  mkdir -p "/data/local/userinit.d"
  [ -f "/data/local/userinit.sh" ] || echo "#!/system/bin/sh" > "/data/local/userinit.sh"
  chmod 0755 "/data/local/userinit.sh"
  set_perm_recursive "$ETC/init.d" 0 0 0755 0644
}

[ -e $TMP/system/addon.d/80-nethunter.sh ] && {
  ui_print "* Installing /system/addon.d backup scripts"
  mkdir -p "$TARGET/addon.d"
  cp "$TMP/system/addon.d/80-nethunter.sh" "$TARGET/"
  cp "$TMP/system/addon.d/80-nethunter.sh" "$TARGET/addon.d/"
  set_perm_recursive "$TARGET/addon.d" 0 0 0755 0644
}

#------------------------------------------------------------------------------

# Symlink bootkali* scripts for using in another terminals
# May need to start up NetHunter.apk first!
if [ -e /data/data/com.offsec.nethunter/assets/scripts/ ]; then
  ui_print "* Symlinking NetHunter.apk boot scripts"
  symlink "/data/data/com.offsec.nethunter/assets/scripts/bootkali" "$TARGET/bin/bootkali" || ui_print "[!] Missing bootkali"
  symlink "/data/data/com.offsec.nethunter/assets/scripts/bootkali_init" "$TARGET/bin/bootkali_init" || ui_print "[!] Missing bootkali_init"
  symlink "/data/data/com.offsec.nethunter/assets/scripts/bootkali_login" "$TARGET/bin/bootkali_login" || ui_print "[!] Missing bootkali_login"
  symlink "/data/data/com.offsec.nethunter/assets/scripts/bootkali_bash" "$TARGET/bin/bootkali_bash" || ui_print "[!] Missing bootkali_bash"
  symlink "/data/data/com.offsec.nethunter/assets/scripts/killkali" "$TARGET/bin/killkali" || ui_print "[!] Missing killkali"
else
  ui_print "[!] Magisk doesn't have permission to access boot scripts"
fi
set_perm_recursive "$BIN" 0 0 0755 0755

#------------------------------------------------------------------------------

## Adding required permissions for NetHunter app
ui_print "* Granting required permissions to NetHunter app"
pm grant -g com.offsec.nethunter android.permission.INTERNET
pm grant -g com.offsec.nethunter android.permission.ACCESS_WIFI_STATE
pm grant -g com.offsec.nethunter android.permission.CHANGE_WIFI_STATE
pm grant -g com.offsec.nethunter android.permission.READ_EXTERNAL_STORAGE
pm grant -g com.offsec.nethunter android.permission.WRITE_EXTERNAL_STORAGE
pm grant -g com.offsec.nethunter com.offsec.nhterm.permission.RUN_SCRIPT
pm grant -g com.offsec.nethunter com.offsec.nhterm.permission.RUN_SCRIPT_SU
pm grant -g com.offsec.nethunter com.offsec.nhterm.permission.RUN_SCRIPT_NH
pm grant -g com.offsec.nethunter com.offsec.nhterm.permission.RUN_SCRIPT_NH_LOGIN
pm grant -g com.offsec.nethunter android.permission.RECEIVE_BOOT_COMPLETED
pm grant -g com.offsec.nethunter android.permission.WAKE_LOCK
pm grant -g com.offsec.nethunter android.permission.VIBRATE
pm grant -g com.offsec.nethunter android.permission.FOREGROUND_SERVICE

#------------------------------------------------------------------------------

## Install kernel
ui_print "* Flashing kernel"
flash_kernel || ui_print "[!] Failed to flash kernel"

#------------------------------------------------------------------------------

## Install chroot
ui_print "* Installing chroot"
do_chroot || ui_print "[!] Failed to install chroot"

#------------------------------------------------------------------------------

## Random important Magisk stuff (Don't remove)
ui_print "* Important Magisk items"
cp -fp $TMP/module.prop $MNT/$MODID/
touch $MNT/$MODID/auto_mount
[ -e /data/adb/modules ] && IMGMNT=/data/adb/modules
mkdir -p "$IMGMNT/$MODID"
touch "$IMGMNT/$MODID/update"
cp -fp $TMP/module.prop "$IMGMNT/$MODID/"

#------------------------------------------------------------------------------

ui_print "* Restoring environment"
cd /

## Restore environment after installations
if [ -d /dev/block/mapper ]; then
  for block in system; do
    for slot in "" _a _b; do
      blockdev --setro /dev/block/mapper/$block$slot 2>/dev/null
    done
  done
fi
[ "$SAR" ] && mount -o ro,remount -t auto / || mount -o ro,remount -t auto /system

## Restore also additional settings we did before
settings put global verifier_verify_adb_installs $VERIFY
$ENFORCE && setenforce 1

## Handle replace folders
for TARGET in $REPLACE; do
  ui_print "* Replace target: $TARGET"
  mktouch $MODPATH$TARGET/.replace
done

#------------------------------------------------------------------------------

## Clean up
ui_print "* Cleaning up"
[ -n "$DEBUG" ] || rm -rf $TMPDIR
umask $UMASK

## Done

#------------------------------------------------------------------------------

#<REF: ./scripts/util_functions.sh>
## Update info for Magisk
print "* Setting Magisk metadata"
mktouch /data/adb/modules/$MODID/update
rm -rf /data/adb/modules/$MODID/remove 2>/dev/null
rm -rf /data/adb/modules/$MODID/disable 2>/dev/null
cp -af $MODPATH/module.prop /data/adb/modules/$MODID/module.prop

## Copy over custom sepolicy rules
if [ -f $MODPATH/sepolicy.rule ]; then
  print "* Installing custom sepolicy rules"
  copy_preinit_files
fi

## Remove stuff that doesn't belong to modules and clean up any empty directories
rm -rf $MODPATH/update-magisk \
       $MODPATH/system/placeholder \
       $MODPATH/customize.sh \
       $MODPATH/README.md \
       $MODPATH/.git*
#rmdir -p $MODPATH 2>/dev/null

cd /
[ -n "$DEBUG" ] || rm -rf $TMPDIR
#</REF: ./scripts/util_functions.sh>
